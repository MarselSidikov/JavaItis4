------------------
http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
java -version
javac -version (прописать в переменную среды Path путь к папке bin jdk)

Установить: Sublime Text 2, либо Atom, Notepad++
Командная строка: https://git-scm.com/downloads, команды cd, ls

-----------------

1) Преобразование типа - преобразование значения одного типа в другое.
2) Неявное преобразование - выполняется от меньшего к большему автоматически. int -> double. Например: double y = 7;
3) Явное преобразование - преобразование между типами с потерей результата. Для того, чтобы программист всегда видел, что результат может быть потерян, необходимо записывать инструкцию преобразования явно:
double -> int необходимо: int x = (int)7.8;

------------------------------
Изучить: ASCII и UNICODE

ASCII - таблица символов, номер_символа = сам_символ
0..32 - управлящие символы, '\n' - символ перехода на новую строку, '\t' - символ табуляции
32 - 127 - символы английского алфавита
128 - 255 - все остальное

UNICODE - таблица символов, но каждый символ занимает 2 байта
------------------------------
Бема-Якоппини - что любой алгоритм можно выразить с помощью комбинации трех структур управления - линейная структура управления, условная структура управления, цикл.

Алгоритм - последовательность операций
1) Ввод
2) Вывод
3) Эффективность
4) Конечность
5) Детерминированность/однозначность

Задача: есть набор чисел A = {a1, a2, ..., an}

n -> бескон	ечность
an = -1

Посчитать сумму чисел. Посчитать сумму четных чисел.

TaskN
ДЗ на числа:
1) Клиент приходит в банк, и просит снять сумму определенную, надо вывести:
5000 - 
1000 - 
500 - 
100 - 
50 -
10 - 
5 - 
2 - 
1 -
2) Сумма цифр считанного числа
ДЗ на последовательности:
3) Посчитать сумму отрицательных чисел
4) Посчитать произведение положительных И сумму нечетных чисел
5) Посчитать произведение чисел, сумма цифр которых оканчивается на 7
6) Посчитать сумму чисел, порядок вхождения которых - четное число

Определение:
Массив - набор элементов фиксированного размера, каждый из которых доступен по индексу.
- грубо говоря: массив - набор пронумерованных переменных

ДЗ на массивы:
7) Сумма чисел массива
8) Сумма элементов, стоящих на нечетных позициях
9) Количество локальных максимумов a[i-1] <= a[i] > a[i+1]

ДЗ:
10) Степени двойки
11) ДОДЕЛАТЬ/СДЕЛАТЬ/ПЕРЕДЕЛАТЬ домашки
12) Пусть есть два массива символов text[], word[], длина word < длина text. Надо найти позицию, с которой word входит в text
char text[] = {'H', 'e, 'l', 'l', 'l', 'o'};
char word[] = {'l','l','o'};
result - 3
13) Попробовать реализовать через Кнута-Морриса-Пратта

-----------------------------------
Подпрограмма - программа внутри основной программы. Подпрограмма может быть многократно вызвана. У подпрограммы обязательно есть имя. Подпрограммы могут иметь формальные параметры. Подпрограммы делятся на две группы
	1. функции - подпрограммы, которые явно возвращают результат своего выполнения.
		y = f(x);
		f - название функции
		x - формальный параметр функции

		6 = f(7);
		7 - аргумент, подставляется в формальный параметр

		// объявление функции
		// int - тип возвращаемого значения
		// sum - название функции
		// int a, int b - формальные параметры
		// return - оператор возврата
		public static int sum(int a, int b) {
			int result = a + b;
			return result;
		}

	public static void main(String[] args) {
		int x = 7;
		int y = 8;
		//x, y - аргументы
		//sum(x,y) - вызов функции
		// x копируется в a, y копируется в b
		// результат их суммы будет вместо вызова
		int sumXY = sum(x, y);

		System.out.println(sumXY);
	}

	Если функции имеют одинаковые названия, но разные формальные параметры - они называются перегруженными.

ДЗ на функции:
14) Написать функции, которые ищут минимальный и максимальный элементы массива
15) Написать фукнцию, решающую квадратное уравнение. Она должна возвращать массив корней
	
	2. процедуры - это подпрограмма, которая явно не возвращает значения своего выполнения, но, обязательно обладает побочным эффектом

16) Написать процедуру, которая выводит минимальные числа в каждой строке
17) Написать процедуру, которая выводит минимальные числа в каждом столбце
18) Написать процедуру, котрая выводит максимальное число на побочной диагонали квадратной матрицы
19) попробовать написать оптимальный вариант фибонначи
-----------------------------------------------------------
Примитивные типы: int, char, boolean, double, byte, long, float, short (приведение типов - явное и неявное)
Ссылочные типы - массивы (они хранят ссылку на значение)
Базовые конструкции java - if, while, for
Подпрограммы (тип возвращаемого значения, return, формальные параметры и аргументы) - функции (непосредственно возвращают значения, процедуры - непосредственно значения не возвращают, тип возвращаемого значения - void). Подпрограммы в java - методы.
Массивы - выделение памяти (new), явная инициализация
Многомерные массивы.
Рекурсия - стек вызовов.
-----------------------------------------------------------
Объект - некоторая сущность, обладающая состоянием (свойства) и поведением (действия).
Маша
СОСТОЯНИЕ:
- пол: женский
- возраст: 24
- рост: 1 71
- вес: 49
- цвет волос: Рыжий
- цвет глаз: зеленый
- профессия: ведьма
ПОВЕДЕНИЕ:
- наколдавать()
- приворожить()
Класс - абстрактный тип данных (ссылочный), (описывается методом абстракции - выделение значимых характеристик в контексте решаемой задачи). Класс описывает возможные состояния и поведения объекта.
Объект - экземпляр класса.
-------------------------------
Класс - отдельный файл (обычно), файл и класс имеют (обязательно) ОДНО НАЗВАНИЕ.

Human marsel; - объявление объектной переменной (переменная, указывающая на объект, изначально - null).
marsel = new Human(); - создание объекта, теперь marsel указывает на объект.
Поля (члены класса) - переменные внутри класса. Конкретные значения полей задают состояние объекта.

Инстантивация - создание объекта (instance), оператор new.   
Инициализация - задание начального состояния объекта.

Конструктор (не является членом класса) - набор инструкций внутри класса, которые говорят, как именно нужно инициализировать объект. По виду конструктор очень сильно похож на метод, имеет название(такое же, как и класс, может иметь формальные параметры, но не имеет типа возвращаемого значения, и не является методом вообще).

В джава по умолчанию для каждого класса автоматически создается пустой конструктор (конструктор по умолчанию).
Переопределение конструктора - написание своего конструктора с нужными действиями инициализации.
Если вы определили свой конструктор с параметрами, то конструктора по умолчанию больше нет.

Класс - поля, конструктор (чтобы отдельно не писать инструкции по заданию начального состояния.)

Метод(член класса) - подпрограмма внутри класса. Описывает поведение объекта. Вызывается непосредственно из созданного объекта.

Парадигма программирования - стиль организации вычислений внутри программы + стиль мышления программиста.

Парадигма процедурного программирования:
программа = алгоритм + структура данных (С, Pacsal, Basic)
+ хорошая ориентация на алгоритмы
+ большое внимание уделяется оптимизации структур данных
- спагетти код (функция вызывает функцию, которая вызывает функцию)
- описать сущности конкретные достаточно трудно
- незащищенность данных

Парадигма логического программирования:
программа = логические придикаты (функции принимающие значение истина и ложь - язык Prolog)

Парадигма функционального программирования:
программа = функция

Парадигма объектно-ориентированного программирования:
программа = объекты, посылающие друг другу сообщения

Четыре кита ООП
1) Абстракция
2) Инкапсуляция 
	2.1 Совмещение алгоритмов и структур данных в одной сущности-капсуле - объект.
	2.2 Возможность обеспечения защиты внутреннй структуры данных
3) Наследование
4) Полиморфизм

Задача - посчитать количество людей определенных возрастов (решили на паре).

Уровень доступа - публичный, приватный, защищенный, публичный в пакете
Модификатор доступа - public, private, protected, (не указывается)

Метод доступа - вспомогательный метод, который позволяет контролируемо работать с защищенными данными

ИТОГО:

Класс состоит из:
1) Приватных (private) полей
2) Конструкторов (пустого и с формальными параметрами)
3) Методы 
4) Методы доступа - getters/setters (getИмяПоля, setИмяПоля)

20) Сортировать людей по возрасту используя ООП (методом пузырька) - задать массив из 15 человек.

---------------------------------------------
Статические члены класса и статические инициализаторы.

Статическое поле (с модификатором static) - глобально для всех объектов.

ДЗ ДОПОЛНИТЕЛНО - все по static (поля, инициализаторы)

СОВЕТЫ:

1) Создавать неизменяемые объекты.Начальное состояние передавать в конструкторе, там выполнять все проверки, а доступ к изменению - не давать. (поля закрыты, сеттеров нет)
ДЗ:
21) Добавить в ArrayList - removeLast, removeFirst, removeByIndex(int index), remove(int element)

Список (List) - абстрактный тип данных, представляющий собой хранилище элементов более высокого уровня, нежели массив с операциями - добавить, удалить, найти и т.д.
ArrayList - реализация списка на основе массива.

Стэк - список, поддерживающий работу только с последним добавленным элементом (принцип LastInputFirstOutput - последним вошел, первым вышел);
- положить наверх (push)
- взять сверху (pop)
ДЗ: проверка последовательности скобок

Очередь и Граф разобрать.

Очередь - список, поддерживающий взятие последнего и добавление первого.
- положить в начало (enqueue)
- взять с конца (dequeue)

Граф - множество вершин и множество ребер.
- Добавить вершину (не у нас)
- Добавить ребро
- Найти количество соседей вершины
- Найти вершину с максимальным количеством соседей
- Получить массив всех соседей
- Проверить, есть ли ребро между вершинами

22) Стек и очередь на основе связных списков
LinkedStack
LinkedQueue
23) Пофиксить remove + сделать метод reverse в LinkedList
24) Карманная сортировка по году

Наследование - механизм ООП, позволяющий объектам класса потомка,
копировать и переопределять состояние и поведение объектов класса предка.
Чтобы наследование было адекватным, важно принименять правило -
все объекты потомка, являются предком.
При наследовании конструктор не наследуется. (конструктор не является членом класса)
Переопределение методов - запись новой реализации метода в классе потомке с той
же сигнатурой что и в предке.
protected - модификатор доступа, который позволяет классу потомку получить
доступ к членам класса предка.
Если метод в потомке не переопределен, то вызывается метод предка.

ПОЧИТАТЬ: UML, SOLID

Полиморфизм - механизм ООП, позволяющий работать с объектами разных типов
таким образом, будто они принадлежат одному типу.

Восходящее преобразование - смена типа объектной переменной с типа класса потомка
на тип класса предка. (неявное преобразование).

Абстрактный класс - класс, экземпляры которого
создавать нельзя. Используется модификатор abstract
Абстрактный метод - метод без реализации.

--------
ДЗ 25:
Создать класс ParkingPlace
Внутри массив типа Transport (абстрактный класс)
Методы ParkingPlace
- припарковатьМашину
- убратьМашину

Transport
- уехать()
- приехать()
- госномер
Несколько видов транспорта
--------------------
1) В Java множественное наследование запрещено
2) Зачем мне классы, в которых есть только методы?

Интерфейс - фактически это
полностью абстрактный класс без полей
Семантически - интерфейс это инкапсуляция поведения
Интерфейс говорит, какое поведение
должно быть у классов, которые его имплементируют
Между собой интерфейсы наследуются

ДЗ: тоер.
1) Классы и объекты + объектные переменные
2) Члены класса + конструкторы
3) Статические члены класса
4) Статические инициализаторы
5) Инкаспуляция и методы доступа
6) Наследование + восходящее преобразование
7) Интерфейсы, полиморфизм, абстрактные классы
8) Класс Object, методы - equals и toString
9) String, что значит final класс, equals, StringPool, intern

26) Описать класс MyString и реализовать Comparable
сравнение в лексикографическом порядке.
гуглить: лексикографический порядок
НЕ ГУГЛИТЬ И НЕ СМОТРЕТЬ - Java Comparable и класс String
27) Реализовать бинарный поиск в упроядоченном массиве
public static <V> V binarySearch(V[] objects, Comparator<V> comparator)
public static <V> V binarySearch(Comparable<V> objects[]);

Обобщения - дженерики - подстановочные типы

try - помечаем блок кода, где возможна исключительная ситуация
catch - указываем тип возможной ошибки, ее объект и инструкции по ее разрешению

ArithmeticException - ошибка арифмитичского выражения
StackOverflow - переполнение стека вызовов
FileNotFoundException - не найден файл

Error - системные ошибки
VirtualMachineError - потомок Error
StackOverflowError - потомок VirtualMachineError
OutOfMemory - потомок VirtualMachineError

RuntimeException - непроверяемые исключения
К непроверяемым исключениям также относят Error

ArithmethicException - непроверяемое, потомок RuntimeException
IllegalArgumentException - непроверяемое, потомок RuntimeException
Exception - проверяемые исключения
FileNotFoundException - проверяемое, потомок Exception

Проверяемое исключение вы ОБЯЗАНЫ ОБРАБОТАТЬ try-catch
Если метод генерирует проверяемое исключение, вы обязаны поставить throws
throw new - выброс исключение
throws - вы говорите, что метод может быть источником проверяемого исключения

1) Структуры управления
2) Типы данных в Java
3) Массивы
4) Классы и объекты
5) Инкапсуляиция
6) Члены класса
7) Статические члены класса
8) Инициализаторы
9) Наследование - абстрактные классы
10) Полиморфизм - интерфейсы
11) Класс Object
12) Класс String
13) Comparable + Compare
14) Обобщения
15) Исключения
16) Обобщенный ArrayList

27) Обобщенный LinkedList

-------------
Java IO - набор классов для работы с вводом
и выводом, пакет java.io
http://www.novsu.ru/file/3619

В основе набора класса лежат четыре класса:
Stream - последовательность байтов
Изначально доступны три базовых потока:
System.in
System.err
System.out

InputStream
    int read() - считать байт из потока
    int read(byte b[]) - считывает байты в массив b, количество считанных байт возвращает как результат
OutputStream
    write(int b)  - записывает байт в поток
    write(byte b[]) - записывает массив байтов в поток

FileInputStream/FileOutputStream - реализация потоков на файлах
ByteArrayInputStream/ByteArrayOutputStream - потоки над массиво байтов
ObjectInputStream/ObjectOutputStream - для сериализации
BufferedInputStream/BufferedOutputStream
Reader
Writer
-----------------------------------------
Паттерн - классическое решение какой-либо общей проблемы.

Паттерн проектирования DAO - Data Access Object
Проблема: сильная зависимость логики приложения от
хранилища данных.
Решение: прослойка-интерфейс, предоставляющая набор операций
для работы с данными + конкретные реализации под конкретное хранилище

28) 1) Дома: заменить User[] на ArrayList<T>
    2) Есть проблема - вызывав findAll один раз, второй раз его не вызовишь.
    Решить эту проблему